/*********************************************************************************

 Copyright 2006-2008 MakingThings

 Licensed under the Apache License, 
 Version 2.0 (the "License"); you may not use this file except in compliance 
 with the License. You may obtain a copy of the License at

 http://www.apache.org/licenses/LICENSE-2.0 
 
 Unless required by applicable law or agreed to in writing, software distributed
 under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
 CONDITIONS OF ANY KIND, either express or implied. See the License for
 the specific language governing permissions and limitations under the License.

*********************************************************************************/

#include "AT91SAM7X256.h"
#include "Board.h"
#include "io_cpp.h"
#include "pwm.h"
#include "error.h"

#define PWM_DUTY_MAX 1024
#define PWM_COUNT 4
#define PWM_CHANNEL_0_IO IO_PB19
#define PWM_CHANNEL_1_IO IO_PB20
#define PWM_CHANNEL_2_IO IO_PB21
#define PWM_CHANNEL_3_IO IO_PB22

// statics
int Pwm::activeChannels = 0;

/** \defgroup Pwm PWM (Pulse Width Modulation)
	The PWM subsystem provides control of the 4 PWM outputs on the SAM7X.

  The Make Controller has 4 PWM lines.  These can each be configured separately and can control
  up to 2 output lines directly, the 2 lines running either parallel or inverted.  For a very simple
  start, just see Pwm_Set( ) and Pwm_Get( ) as these will start driving your PWMs immediately with
  very little hassle.  

  \section padjust Period adjustment of the PWM unit
  Configuring and setting the clock for the PWM system can be quite a complicated matter.  Here are 
  some of the relevant issues.
  
  Each of the 4 PWM channels is fed in a clock, as determined by its clock source:
   - Clock source 0-10 represent the Master clock divided by 2 to the power of the Clock Source Value.  eg. a clock 
   source value of 5 = a clock rate of MasterClock/(2^5)
   - A value of 11 sets the Clock source to be generated by clock Divider A (Default)
   - A value of 12 sets the Clock source to be generated by clock Divider B
  
  If either Clock Divider A or Clock Divider B is used, you can adjust their values individually to
  allow the clock period to precisely match your needs.  Each clock divider has two values, a \b Mux value 
  and a \b Divider value.  
  
  The mux works just like the clock source values, and chooses Master clock divided by 2 to 
  the power of the Clock Source Value, eg. a DividerXMux value of 5 == a clock rate of MasterClock/(2^5).
  The Divider value sets a linear divider, which is fed the clock value as selected by the Mux, and returns that 
  clock value divided by the divider value.  This output value is what is fed out of the divider unit.  A output 
  formula: 
  \code output = MCLK / ( (2^DividerMux) * DividerValue ) \endcode
	
  The PWM subsystem of the Controller Board can be used independently from the \ref PwmOut 
  library, since the \ref PwmOut library relies on the core PWM.

	\ingroup Core
	@{
*/

Pwm::Pwm( int channel )
{
  this->channel = channel; // might as well write this in here so it's invalid instead of possibly defaulting to 0
  if ( channel < 0 || channel >= PWM_COUNT )
    return;
  
  // IO line should use peripheral A
  Io pwmPin( getIo( channel ), IO_A );

  // Enable the current channel
  AT91C_BASE_PWMC->PWMC_ENA = 1 << channel;
  if(!activeChannels)
    baseInit();
  activeChannels |= (1 << channel); // mark it as used
}

Pwm::~Pwm( )
{
  Io pwmPin( getIo( channel ) );
  pwmPin.off(); // turn it off

  int c = 1 << channel;
  AT91C_BASE_PWMC->PWMC_DIS = c; // disable this channel
  activeChannels &= ~c; // mark it as unused
  if(!activeChannels) // if that was our last channel, turn everything off
    baseDeinit();
}

/**	
	Set the duty of a PWM device.
	@param index An integer specifying which PWM device (0-3).
  @param duty The duty - (0 - 1023).
	@return 0 on success.
*/
void Pwm::setDuty( int duty )
{
  this->duty = duty;
  AT91C_BASE_PWMC->PWMC_CH[channel].PWMC_CMR &= ~AT91C_PWMC_CPD;
  AT91C_BASE_PWMC->PWMC_CH[ channel ].PWMC_CUPDR = duty;
}

/**	
	Read the current duty of a PWM device.
	@param index An integer specifying which PWM device (0-3).
  @return The duty - (0 - 1023).
*/
int Pwm::getDuty( )
{
  return duty;
}

int Pwm::baseInit()
{
  // Configure PMC by enabling PWM clock
  AT91C_BASE_PMC->PMC_PCER = 1 << AT91C_ID_PWMC;

  // Initially they're stopped
  AT91C_BASE_PWMC->PWMC_DIS = AT91C_PWMC_CHID0 | AT91C_PWMC_CHID1 | AT91C_PWMC_CHID2 | AT91C_PWMC_CHID3;
  
  // Set the Clock A divider
  AT91C_BASE_PWMC->PWMC_MR = (( 4 << 8 ) | 0x08 );  // MCK selection or'ed with Divider

  // Set the Clock
  int i;
  for ( i = 0; i < 4; i++ )
  {
    AT91S_PWMC_CH *pwm = &AT91C_BASE_PWMC->PWMC_CH[ i ];

    pwm->PWMC_CMR =
      // AT91C_PWMC_CPRE_MCK |  // Divider Clock ? 
         AT91C_PWMC_CPRE_MCKA |    //Divider Clock A
      // AT91C_PWMC_CPRE_MCKB;  //Divider Clock B
      // AT91C_PWMC_CPD;  // Channel Update Period 
         AT91C_PWMC_CPOL; // Channel Polarity Invert
      // AT91C_PWMC_CALG ; // Channel Alignment Center

    pwm->PWMC_CPRDR = PWM_DUTY_MAX; // Set the Period register (sample size bit fied )
    pwm->PWMC_CDTYR = 0;            // Set the duty cycle register (output value)
    pwm->PWMC_CUPDR = 0 ;           // Initialise the Update register write only
  }
  return CONTROLLER_OK;
}

int Pwm::baseDeinit()
{
  // Deconfigure PMC by disabling the PWM clock
  AT91C_BASE_PMC->PMC_PCDR = 1 << AT91C_ID_PWMC;

  return CONTROLLER_OK;
}

int Pwm::getIo( int channel )
{  
  switch ( channel )
  {
    case 0:
      return PWM_CHANNEL_0_IO;
    case 1:
      return PWM_CHANNEL_1_IO;
    case 2:
      return PWM_CHANNEL_2_IO;
    case 3:
      return PWM_CHANNEL_3_IO;
    default:
      return 0;
  }
}

void Pwm::setWaveform( bool left_aligned, bool starts_low )
{
  unsigned int alignment = left_aligned ? 0 : 1;
  unsigned int polarity = starts_low ? 0 : 1;
  // Disable channel (effective at the end of the current period)
  if ((AT91C_BASE_PWMC->PWMC_SR & (1 << channel)) != 0) {
    AT91C_BASE_PWMC->PWMC_DIS = 1 << channel;
    while ((AT91C_BASE_PWMC->PWMC_SR & (1 << channel)) != 0);
  }

  // Configure channel
  AT91C_BASE_PWMC->PWMC_CH[channel].PWMC_CMR = alignment | polarity;
}

void Pwm::setFrequency(int freq)
{
  unsigned int mode = 0;
  unsigned int result = findClockConfiguration( freq );
  mode |= result;
  /*
    All channels use clock divider A currently, so we can just set the frequency there
    and be done with it.  If we also wanted to configure channel B, we'd do something like
    result = findClockConfiguration( freq );
    mode |= (result << 16);
  */
  AT91C_BASE_PWMC->PWMC_MR = mode;
}

int Pwm::getFrequency()
{
  return 0;
}

int Pwm::findClockConfiguration(int frequency)
{
  unsigned int mck = MCK;
  unsigned int divisors[11] = {1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024};
  unsigned char divisor = 0;
  unsigned int prescaler;

//    SANITY_CHECK(frequency < mck);

  // Find prescaler and divisor values
  prescaler = (mck / divisors[divisor]) / frequency;
  while ((prescaler > 255) && (divisor < 11))
  {
    divisor++;
    prescaler = (mck / divisors[divisor]) / frequency;
  }

  // Return result
  if (divisor < 11)
//      TRACE_DEBUG("Found divisor=%u and prescaler=%u for freq=%uHz\n\r",
//                divisors[divisor], prescaler, frequency);
    return prescaler | (divisor << 8);
  else
    return 0;
}

/** @}
*/
