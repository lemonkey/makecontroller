/********************************************************************************* Copyright 2006 MakingThings Licensed under the Apache License,  Version 2.0 (the "License"); you may not use this file except in compliance  with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0  Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. *********************************************************************************//** 	An OscMessage includes two properties, an \b address and a list of \b arguments.		\section Address	The address is of type \b String and can be accessed with the . operator.	<h3>Example</h3>	\code	var oscM = new OscMessage( );	oscM.address = "/appled/0/state";	\endcode		\section Arguments	The list of arguments is simply an \b Array named \b args.  The array can hold 	any kind of data type, but currently only \b Strings and \b Numbers are parsed.  	Access it with the . operator as well.	<h3>Example</h3>	\code	var oscM = new OscMessage( );	oscM.address = "/appled/0/state";	oscM.args[0] = "1";	\endcode		Or, you can intialize both the address and args values at the time you create the instance:	\code	var oscM = new OscMessage( "/appled/0/state", "1" );	\endcode		\section bundles OSC Bundles	You may also want to create a bundle of several messages to reduce the number of packets being sent.	A bundle is simply an \b Array filled with items of type OscMessage. To send them, use the sendBundle()	or sendBundleToAddress() functions.  		You never need to worry about unpacking a bundle, as this is already done for you.  You just	get the unpacked messages.  		<h3>Example</h3>	\code	var msg1 = new OscMessage( "/appled/1/state", "1" );	var msg2 = new OscMessage( "/servo/2/position", "512" );	var oscBundle = new Array( msg1, msg2 );	flosc.sendBundle( oscBundle );	// now both messages are sent in a single packet.	\endcode*/class com.makingthings.makecontroller.OscMessage{	/** The OSC address of the message. This must start with a / */	public var address:String;	/** A list of zero or more arguments being sent to that OSC address. Arguments	can be of type string, int, or float. If you have no arguments, simply provide an empty array	by passing in [] */	public var args:Array;	/** For incoming OscMessages, this indicates which board it was sent from.  For boards communicating via Ethernet, this will be an IP address.	For USB boards, it will be some unique identifier - on Windows it will look like "COM9" and on OS X it will be a long, nasty device location string.	This property is not relevant for outgoing OscMessages. */	public var from:String;	public var time:Number;		/**	Create a new OscMessage.		@param address The OSC address of this message	@param args An array of arguments.  To specify no arguments, simply use []	@param from An optional string indicating where the message originated from. This is mostly used	internally by the Flosc library for incoming messages, and does not need to be set for outgoing messages.		*/	function OscMessage( address:String, args:Array, from:String )	{		this.address = address;		this.from = from;		this.args = args;		this.time = 0;	}		/**	Return a string representing an OscMessage, with the arguments following the address, each separated by a space.	<p>This will look like <pre> /address arg1 (arg2) (argN) </pre></p>	@return The OscMessage as a string, not including the <b>from</b> string.	*/	public function toString( ):String	{		var msg:String = this.address;		var numOfArgs:Number = this.args.length;		for( var i = 0; i < numOfArgs; i++ )			msg = msg.concat( " " + this.args[i].toString() );		return msg;	}}