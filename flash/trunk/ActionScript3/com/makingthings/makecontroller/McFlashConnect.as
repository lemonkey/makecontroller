/********************************************************************************* Copyright 2006 MakingThings Licensed under the Apache License,  Version 2.0 (the "License"); you may not use this file except in compliance  with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0  Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. *********************************************************************************/package com.makingthings.makecontroller{		import flash.net.XMLSocket;	import flash.xml.XMLDocument;	import flash.xml.XMLNode;	import flash.events.*;		/** 		<p>Mchelper (Make Controller Helper) is a separate application that must be run simultaneously with your Flash application.		Because Flash can't connect to external devices by itself, Mchelper is a necessary intermediate step - 		it can connect to the Make Controller over the network and via USB, and then it formats communication with the board		into XML that can be fed in and out of Flash.  <b>McFlashConnect</b> makes a connection to Mchelper from your Flash movie.</p>				<p>McFlashConnect needs to know about a few values concerning the network configuration:		<ul>		<li><b>mchelperAddress</b> is the IP address of the machine that Mchelper is running on - the default is <b>localhost</b>.</li>		<li><b>mchelperPort</b> is the port that Mchelper is listening on for connections from McFlashConnect - the default is <b>11000</b>.</li>		<li><b>remoteAddress</b> is the address of the Make Controller that you're communicating with - the default is <b>192.168.0.200</b></li>		<li><b>remotePort</b> is the port that the Make Controller is listening on for incoming messages - the default is <b>10000</b>.</li>		</ul></p>				<p>These are the values that are loaded up by default when you create a new McFlashConnect object.  It's easy to change them for your setup		however, as you'll see below.</p>				<p>McFlashConnect also emits a few events of interest - check these out at in the in the 		<a href="http://www.makingthings.com/ref/flash/as3/McEvent.html">McEvent</a> section.</p>				<p>The easiest way to get started is to check out a few of the example files included in the MakingThings download, and start		modifying things to fit your project.</p>	*/	public class McFlashConnect extends EventDispatcher	{		/** The IP address of the machine running Mchelper. 		<p>Since this usually on the same machine you're running your Flash app on, 		it's usually best to set this to <b>localhost</b></p> */		protected var mchelperAddress;		/** The port that Mchelper is listening for connections from McFlashConnect on. Default is <b>11000</b>.*/		protected var mchelperPort;		/** The IP address of the Make Controller you're communicating with. Default is <b>192.168.0.200</b> */		protected var remoteAddress;		/** The port that the Make Controller you're communicating with is listening on. Default is <b>10000</b>. */		protected var remotePort;		protected var registeredAddresses:Array; // hash of registered addresses and functions to call if a message with that address shows up		protected var mySocket:XMLSocket; 				/**		Create a new instance of McFlashConnect.		@param outAddress An optional string specifying the IP address of the Make Controller you're communicating with.		@param outPort An optional Number specifying the port that the Make Controller you're communicating with is listening on.		*/		function McFlashConnect( outAddress:String = "192.168.0.200", outPort:Number = 10000 )		{			super( );			mchelperAddress = "localhost";			mchelperPort = 11000;			remoteAddress = outAddress;			remotePort = outPort;			registeredAddresses = new Array( );		}				/**		Query the address that McFlashConnect connects to Mchelper at.		By default, this is <b>localhost</b>.		<h3>Example</h3>		<pre>		var myLocalAddress:String = mcflash.getMchelperAddress( );		</pre>				@return A string specifying the current address.		*/		public function getMchelperAddress( ):String		{			return mchelperAddress;		}		/**		Set the address that McFlashConnect connects to Mchelper at.		By default, this is <b>localhost</b>.		<h3>Example</h3>		<pre>		mcflash.setLocalAddress( "192.168.0.215" );		</pre>				@param addr A string specifying the address.		*/		public function setMchelperAddress( addr:String ):void		{			mchelperAddress = addr;		}		/**		Query the port that McFlashConnect connects to Mchelper on.				<h3>Example</h3>		<pre>		var myLocalPort:Number;		myLocalPort = mcflash.getLocalPort( );		</pre>				@return A number specifying the current port.		*/		public function getMchelperPort( ):Number		{			return mchelperPort;		}		/**		Set the port that McFlashConnect connects to Mchelper on.		By default, this is <b>11000</b>.				<h3>Example</h3>		<pre>		// listen on port 10101		mcflash.setLocalPort( 10101 );		</pre>				@param port A number specifying the port.		*/		public function setMchelperPort( port:Number ):void		{			mchelperPort = port;		}				/**		Query the IP address of the Make Controller that McFlashConnect will send OscMessages to.		The default address of the Make Controller is <b>192.168.0.200</b>				<h3>Example</h3>		<pre>		var myRemoteAddress:String;		myRemoteAddress = mcflash.getRemoteAddress( );		</pre>				@return A string specifying the IP address of the device you're sending to		*/		public function getRemoteAddress( ):String		{			return remoteAddress;		}				/**		Set the IP address of the Make Controller that McFlashConnect will send OscMessages to.		<p>The default address of the Make Controller is 192.168.0.200.  This will be the address used by defult when sending messages		unless you use a method that allows you to specify an address explicitly.</p>				<h3>Example</h3>		<pre>		mcflash.setRemoteAddress( "192.168.0.210" );		// now the normal send() method will send to 192.168.0.210		mcflash.send( "/appled/0/state", "1" );		</pre>				@param addr A string specifying the address.		*/		public function setRemoteAddress( addr:String ):void		{			remoteAddress = addr;		}				/**		Query the port that McFlashConnect will send OscMessages on.		By default this is <b>10000</b>.		<h3>Example</h3>		<pre>		var myRemotePort:Number;		myRemotePort = mcflash.getRemotePort( );		</pre>				@return A number specifying the current port.		*/		public function getRemotePort( ):Number		{			return remotePort;		}				/**		Set the port that McFlashConnect will send OscMessages on.		By default this is <b>10000</b>.		<h3>Example</h3>		<pre>		// send messages on port 10101		mcflash.setRemotePort( 10101 );		</pre>				@param port A number specifying the port.		*/		public function setRemotePort( port:Number ):void		{			remotePort = port;		}				/**		Register a handler for messages with a given OSC address.				<p>You can create a function of your own that will get called whenever an incoming OSC message matches		a particular address.  This saves you from checking the address of all incoming OSC messages. </p>				<p>Your callback should be in the form:		<pre> myCallback( msg:OscMessage ); </pre></p>				<h3>Example</h3>		<pre>		addAddressListener( "/analogin/7/value", onTrimpot );				function onTrimpot( msg:OscMessage ) // this will get called whenever a message from /analogin/7/value is received.		{			trace( "new OSC message: " + msg.toString() );		}		</pre>				@param addr The OSC address to match.		@param callback The function that you want to be called back on.		*/		public function addAddressListener( addr:String, callback:Function ):void		{			var handler = new AddressHandler( addr, callback );			registeredAddresses.push( handler );		}				public function connected( ):Boolean		{			return mySocket.connected;		}						// ************************************************************************************************************************************		// OSC stuff		// ************************************************************************************************************************************				// ** parse messages from an XML-encoded OSC packet		protected function parseMessages( node:XMLNode ) : void //this is called when we get OSC packets back from FLOSC.		{				var time:Number = node.attributes.TIME;			var addr:String = node.attributes.ADDRESS;			var message:XMLNode = node.firstChild;			while( message != null )			{				if (message.nodeName == "MESSAGE")				{					var msgName:String = message.attributes.NAME;							var oscData:Array = [];					for (var child:XMLNode = message.firstChild; child != null; child=child.nextSibling)					{						if (child.nodeName == "ARGUMENT")						{							var type:String = child.attributes.TYPE;							//float							if (type=="f") {								oscData.push(parseFloat(child.attributes.VALUE));							} else 							// int							if (type=="i") {								oscData.push(parseInt(child.attributes.VALUE));								//trace( "got int" );							} else 							//string							if (type=="s") {								oscData.push(child.attributes.VALUE);							}							}					}					var msg:OscMessage = new OscMessage( msgName, oscData, addr );					msg.time = time;					doCallback( msg );					message = message.nextSibling; // move to the next MESSAGE node, if there is one				}				else					break;			}		}				protected function doCallback( msg:OscMessage ) : void		{			var knownAddresses:Number = registeredAddresses.length;			var calledBack:Boolean = false;			for( var i:int = 0; i < knownAddresses; i++ )			{				if( registeredAddresses[i].address == msg.address )				{					registeredAddresses[i].callback( msg );					calledBack = true;				}			}			if( !calledBack )				dispatchEvent(new McEvent( McEvent.ON_MESSAGE_IN, msg) );		}				/**		Connect McFlashConnect up to Mchelper.		This will connect using the current values of <b>mchelperAddress</b> and <b>mchelperPort</b>.				<h3>Example</h3>		<pre> 		// use the default network address of the Make Controller (vary as needed)		mcflash.setLocalAddress( "192.168.0.200" );		mcflash.setLocalPort( 10000 );		// then connect		mcflash.connect( );		</pre>		*/		public function connect( ) : void		{			mySocket = new XMLSocket();			mySocket.addEventListener( Event.CONNECT, onXmlConnect );			mySocket.addEventListener( Event.CLOSE, onXmlClose );			mySocket.addEventListener( DataEvent.DATA, onXmlIn ); 			mySocket.addEventListener( IOErrorEvent.IO_ERROR, onXmlConnectionError );					mySocket.connect(mchelperAddress, mchelperPort);		}				protected function onXmlConnectionError( e:Event ) : void		{			dispatchEvent( new McEvent( McEvent.ON_CONNECT_ERROR ) );		}				/**		Disconnect from the FLOSC server.				<p>This closes the XML connection to FLOSC.  This does not need to be called explicitly before closing your movie.</p>				<h3>Example</h3>		<pre> 		mcflash.disconnect( );		</pre>		*/		public function disconnect( ) : void		{			if( mySocket.connected )				mySocket.close();			else				return;		}				protected function onXmlClose( e:Event )		{			dispatchEvent( new McEvent( McEvent.ON_CLOSE ) );		}				// *** event handler for incoming XML-encoded OSC packets		protected function onXmlIn( e:DataEvent ) : void		{			// parse out the packet information			var xmlIn:XMLDocument = new XMLDocument( ); //e.data);			xmlIn.ignoreWhite = true;			xmlIn.parseXML( e.data );			var n:XMLNode = xmlIn.firstChild;			if (n != null && n.nodeName == "OSCPACKET")				parseMessages( n );		}				// *** event handler to respond to successful connection attempt		protected function onXmlConnect( succeeded:Boolean ) : void		{			if(succeeded)				dispatchEvent( new McEvent( McEvent.ON_CONNECT ) );			else			{				trace( "Connection to FLOSC did not succeed." );				trace( "** Make sure it's running, and that you've set your mchelperAddress properly." );			}		}				/**		* Send a message to the board.		<p>This will send a message to a board at the current <b>remoteAddress</b> and <b>remotePort</b>.		If you need to specify the IP address and port for each message, use sendToAddress( ).</p>				<h3>Example</h3>		<pre> 		// Specify the OSC address and argument to send - turn on LED 1		mcflash.send( "/appled/1/state", "1" );		</pre>				@param address The OSC address to send to, as type \b String.		@param arg The value to be sent.		@see sendToAddress()		*/		public function send( address:String, args:Array ) : void		{			sendToAddress( address, args, remoteAddress, remotePort );		}				/**		* Send a message to the board, specifying the IP address and port. 				<h3>Example</h3>		<pre> 		// Specify the OSC address and argument to send - turn on LED 1		// Also include the IP address and port you want to send the message to		mcflash.sendToAddress( "/appled/1/state", "1", "192.168.0.235", 11001 );		</pre>				@param address The OSC address of your message.		@param args The value(s) to be sent.		@param destAddr The IP address of the board you're sending to.		@param destPort	 The port to send your message on.		*/		public function sendToAddress( address:String, args:Array, destAddr:String, destPort:Number ) : void		{			var xmlOut:XMLDocument = new XMLDocument();			var packetOut = createPacketOut( xmlOut, 0, destAddr, destPort );			var xmlMessage = createMessage( xmlOut, packetOut, address );			parseArguments( xmlOut, xmlMessage, args );							xmlOut.appendChild(packetOut);					if( mySocket && mySocket.connected )				mySocket.send(xmlOut);		}				// used internally to prep an XML object to be sent out.		protected function createPacketOut( xmlOut:XMLDocument, time:Number, destAddr:String, destPort:Number ):XMLNode		{			var packetOut:XMLNode = xmlOut.createElement("OSCPACKET");			packetOut.attributes.TIME = time;			packetOut.attributes.PORT = destPort;			packetOut.attributes.ADDRESS = destAddr;						return packetOut;		}				// used internally to create a message element within the xmlOut object		protected function createMessage( xmlOut:XMLDocument, packetOut:XMLNode, address:String ):XMLNode		{			var xmlMessage:XMLNode = xmlOut.createElement("MESSAGE");			xmlMessage.attributes.NAME = address;			packetOut.appendChild(xmlMessage);			return xmlMessage;		}				// used internally to determine the type of an argument, and append it to its corresponding message in the outgoing XML object.		protected function parseArguments( xmlOut:XMLDocument, xmlMessage:XMLNode, args:Array ) : void		{			var argument:XMLNode;			var argsLength:Number = args.length;			// NOTE : the server expects all strings to be encoded with the escape function.			for( var i = 0; i < argsLength; i++ )			{				argument = xmlOut.createElement("ARGUMENT");				var argInt = parseInt(args[i]);				if(isNaN(argInt))				{					argument.attributes.TYPE = "s";					argument.attributes.VALUE = escape(args[i]);				} 				else				{					var argString:String = args[i].toString();					var stringLength:int = argString.length;					var float:Boolean = false;					for( var j = 0; j < stringLength; j++ )					{						if( argString.charAt( j ) == "." )						{							argument.attributes.TYPE="f";							argument.attributes.VALUE=parseFloat(argString);							float = true;							break;						}					}					if( !float )					{						argument.attributes.TYPE="i";						argument.attributes.VALUE=parseInt(args[i]);					}				}				xmlMessage.appendChild(argument);			}		}				/**		* Send an OscMessage to the board. 		<p>This will send a message, of type OscMessage, to a board at the current <b>remoteAddress</b> and <b>remotePort</b>.		If you need to specify the address and port for each message, use sendMessageToAddress( ). </p>				<h3>Example</h3>		<pre> 		// create an OscMessage		var turnOnLed:OscMessage = new OscMessage( "/appled/0/state", 1 );		// now send it		mcflash.sendMessage( turnOnLed );		</pre>				@param oscM The message, of type OscMessage, to be sent		@see sendMessageToAddress()		*/		public function sendMessage( oscM:OscMessage ) : void		{			sendMessageToAddress( oscM, remoteAddress, remotePort );		}				/**		* Send an OscMessage to the board, specifying the destination IP address and port. 				<h3>Example</h3>		<pre> 		// create an OscMessage		var turnOffLed:OscMessage = new OscMessage( "/appled/0/state", "0" );		// now send it to a specified address		mcflash.sendMessageToAddress( turnOffLed, "192.168.0.222", 10000 );		</pre>				@param oscM The message, of type OscMessage, to be sent		@param destAddr The IP address of the board you're sending to.		@param destPort	 The port to send your message on.		*/		public function sendMessageToAddress( oscM:OscMessage, destAddr:String, destPort:Number ) : void		{			var xmlOut:XMLDocument = new XMLDocument();			var packetOut = createPacketOut( xmlOut, 0, destAddr, destPort );			var xmlMessage = createMessage( xmlOut, packetOut, oscM.address );				xmlOut.appendChild(packetOut);					if( mySocket && mySocket.connected )				mySocket.send(xmlOut);			//else				//trace( "Couldn't send message - not connected to FLOSC server." );				//trace( "connected? " + this.connected );		}				/**		Send an OscBundle to the board.				<p>This will send an OscBundle to a board at the current <b>remoteAddress</b> and <b>remotePort</b>.		It's a good idea to send bundles when possible, in order to reduce the traffic between the board and Flash.		If you need to specify the address and port for each message, use sendBundleToAddress( ).</p>				<h3>Example</h3>		<pre> 		// create a couple of OscMessages		var turnOffLed:OscMessage = new OscMessage( "/appled/0/state", "0" );		var readAnalogIn:OscMessage = new OscMessage( "/analogin/0/value" );		// create an Array (this Array will be our OscBundle)		// and stuff our messages into it		var myOscBundle:Array = new Array( turnOffLed, readAnalogIn );		// now send it		mcflash.sendBundle( myOscBundle );		</pre>				@param oscB The OscBundle to be sent		@see sendBundleToAddress() 		*/		public function sendBundle( oscB:Array ) : void		{			sendBundleToAddress( oscB, remoteAddress, remotePort );		}				/**		* Send an OscBundle to the board, specifying the destination IP address and port. 				<h3>Example</h3>		<pre> 		// create a few OscMessages		var turnOnLed:OscMessage = new OscMessage( "/appled/3/state", "1" );		var readAnalogIn:OscMessage = new OscMessage( "/analogin/0/value" );		var readDipswitch:OscMessage = new OscMessage( "/dipswitch/value" );		// create an Array (this Array will be our OscBundle)		// and stuff our messages into it		var myOscBundle:Array = new Array( turnOffLed, readAnalogIn, readDipswitch );		// now send it to a specified address		mcflash.sendBundleToAddress( myOscBundle, "192.168.0.213", 10000 );		</pre>				@param oscB The OscBundle to be sent		@param destAddr The IP address of the board you're sending to.		@param destPort	The port to send on.		*/		public function sendBundleToAddress( oscB:Array, destAddr:String, destPort:Number ) : void		{			var xmlOut:XMLDocument = new XMLDocument();			var packetOut = createPacketOut( xmlOut, 0, destAddr, destPort );			for( var i = 0; i < oscB.length; i++ )			{				if( oscB[i] is OscMessage == false )				{					trace( "One of the members in the OscBundle was not an OscMessage...the entire bundle was not sent." );					return;				}					var oscM:OscMessage = oscB[i];				//trace( "Message " + i + ", address " + oscM.address + ", arg: " + oscM.args[0] );				var xmlMessage = createMessage( xmlOut, packetOut, oscM.address );			}				xmlOut.appendChild(packetOut);					if( mySocket && mySocket.connected )				mySocket.send(xmlOut);		}	}} // Package