/* Copyright 2006 MakingThings LLC. */import com.makingthings.makecontroller.OscPacket;import mx.utils.Delegate;class com.makingthings.makecontroller.Osc{	private var localAddress; // whatever your PC's IP address is most likely to be	private var localPort;  //Make Controller default	private var remoteAddress;  //Make Controller default	private var remotePort;  //Make Controller default		private var mySocket:XMLSocket;	private var connected:Boolean;		//Constructor  function Osc( )  {		connected = false;  }		// Network configuration getters and setters	public function getLocalAddress( ):String	{		return localAddress;	}	public function setLocalAddress( addr:String )	{		localAddress = addr;	}		public function getLocalPort( ):Number	{		return localPort;	}	public function setLocalPort( port:Number )	{		localPort = port;	}		public function getRemoteAddress( ):String	{		return remoteAddress;	}	public function setRemoteAddress( addr:String )	{		remoteAddress = addr;	}		public function getRemotePort( ):Number	{		return remotePort;	}	public function setRemotePort( port:Number )	{		remotePort = port;	}			// ********************************************************************	// OSC stuff	// ********************************************************************		// ** parse messages from an XML-encoded OSC packet	function parseMessages( node )  //this is called when we get OSC packets back from FLOSC.	{		if (node.nodeName == "MESSAGE")		{			for (var child = node.firstChild; child != null; child=child.nextSibling)			{				if (child.nodeName == "ARGUMENT")					onOscMessage( node.attributes.NAME, child.attributes.VALUE );			}		}		else { // look recursively for a message node			for (var child = node.firstChild; child != null; child=child.nextSibling) {				parseMessages(child);			}		}	}		public function onOscMessage( address:String, argument:Number )	{			}		// *** create a new socket and attempts to connect to the XML server	function connect ()	{		mySocket = new XMLSocket();		mySocket.onConnect = Delegate.create( this, handleConnect );		//mySocket.onClose = handleClose;		mySocket.onXML = Delegate.create( this, handleIncoming );			if (!mySocket.connect(localAddress, localPort))			trace( "Can't create XML connection to FLOSC." );		//else			//trace( "FLOSC opened ok." );	}		// *** event handler for incoming XML-encoded OSC packets	private function handleIncoming (xmlIn) {		// parse out the packet information		var e = xmlIn.firstChild;		if (e != null && e.nodeName == "OSCPACKET") {			//var packet = new OSCPacket(e.attributes.address, e.attributes.port, e.attributes.time, xmlIn);			//displayPacketHeaders(packet);			parseMessages(xmlIn);		}	}		// *** event handler to respond to successful connection attempt	private function handleConnect (succeeded)	{		if(succeeded)			this.connected = true;		else			trace( "Connection to FLOSC did not succeed - make sure it's running!." );	}		// *** display text information about an OSCPacket object	//function displayPacketHeaders(packet) {		//trace("** OSC Packet from " +packet.address+ ", port " +packet.port+ " for time " +packet.time);	//}		// *** build and send XML-encoded OSC		private function sendOSC(name, arg, destAddr, destPort) {		var xmlOut:XML = new XML();			var osc = xmlOut.createElement("OSCPACKET");		osc.attributes.TIME = 0;		osc.attributes.PORT = destPort;		osc.attributes.ADDRESS = destAddr;			var message = xmlOut.createElement("MESSAGE");		message.attributes.NAME = name;			var argument = xmlOut.createElement("ARGUMENT");		// NOTE : the server expects all strings to be encoded		// with the escape function.		var argInt = parseInt(arg);		if( isNaN( argInt ) )		{			argument.attributes.VALUE = escape(arg);			argument.attributes.TYPE = "s";		} 		else 		{			argument.attributes.VALUE = parseInt(arg);			argument.attributes.TYPE="i";		}				// NOTE : to send more than one argument, just create		// more elements and appendChild them to the message.		// the same goes for multiple messages in a packet.		message.appendChild(argument);		osc.appendChild(message);		xmlOut.appendChild(osc);			if( mySocket && this.connected )			mySocket.send(xmlOut);		else			trace( "Could not send XML-encoded OSC to " +destAddr+ ", port " +destPort );	}}